package com.lago.app.presentation.viewmodel.portfolio

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.lago.app.data.cache.RealTimeStockCache
import com.lago.app.domain.entity.AccountBalance
import com.lago.app.domain.entity.StockHolding
import com.lago.app.domain.entity.StockPriority
import com.lago.app.domain.repository.MockTradeRepository
import com.lago.app.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.sample
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ UI ÏÉÅÌÉú
 */
data class PortfolioUiState(
    val accountBalance: AccountBalance? = null,
    val stockHoldings: List<StockHolding> = emptyList(),
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val totalProfitLoss: Long = 0L,
    val totalProfitLossRate: Double = 0.0,
    val refreshing: Boolean = false
)

@HiltViewModel
class PortfolioViewModel @Inject constructor(
    private val mockTradeRepository: MockTradeRepository,
    private val realTimeStockCache: RealTimeStockCache
) : ViewModel() {

    private val _uiState = MutableStateFlow(PortfolioUiState())
    val uiState: StateFlow<PortfolioUiState> = _uiState

    init {
        loadPortfolio()
        observeRealTimeUpdates()
    }

    /**
     * Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
     */
    fun loadPortfolio() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            
            try {
                // 1. Í≥ÑÏ¢å ÏûîÍ≥† Ï°∞Ìöå
                mockTradeRepository.getAccountBalance().collect { balanceResource ->
                    when (balanceResource) {
                        is Resource.Loading -> {
                            _uiState.update { it.copy(isLoading = true) }
                        }
                        is Resource.Success -> {
                            val accountBalance = balanceResource.data!!
                            _uiState.update { 
                                it.copy(
                                    accountBalance = accountBalance,
                                    isLoading = false
                                )
                            }
                            
                            // 2. Î≥¥Ïú† Ï£ºÏãù Ï°∞Ìöå
                            loadStockHoldings()
                        }
                        is Resource.Error -> {
                            _uiState.update { 
                                it.copy(
                                    isLoading = false,
                                    errorMessage = balanceResource.message
                                )
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        errorMessage = "Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${e.localizedMessage}"
                    )
                }
            }
        }
    }

    /**
     * Î≥¥Ïú† Ï£ºÏãù Î™©Î°ù Ï°∞Ìöå
     */
    private suspend fun loadStockHoldings() {
        mockTradeRepository.getStockHoldings().collect { holdingsResource ->
            when (holdingsResource) {
                is Resource.Loading -> {
                    // Ïù¥ÎØ∏ Î°úÎî© Ï§ë
                }
                is Resource.Success -> {
                    val holdings = holdingsResource.data!!
                    
                    // Î≥¥Ïú† Ï¢ÖÎ™©Îì§ÏùÑ WARM Ïö∞ÏÑ†ÏàúÏúÑÎ°ú ÏÑ§Ï†ï (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
                    val stockPriorities = holdings.associate { it.stockCode to StockPriority.WARM }
                    realTimeStockCache.setMultipleStockPriorities(stockPriorities)
                    
                    android.util.Log.d("PortfolioViewModel", "üìà Î≥¥Ïú† Ï¢ÖÎ™© Ïã§ÏãúÍ∞Ñ Ïö∞ÏÑ†ÏàúÏúÑ ÏÑ§Ï†ï: ${holdings.size}Í∞ú")
                    
                    updatePortfolioWithCurrentData(holdings)
                }
                is Resource.Error -> {
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            errorMessage = holdingsResource.message
                        )
                    }
                }
            }
        }
    }

    /**
     * ÏÉàÎ°úÍ≥†Ïπ®
     */
    fun refresh() {
        viewModelScope.launch {
            _uiState.update { it.copy(refreshing = true) }
            loadPortfolio()
            _uiState.update { it.copy(refreshing = false) }
        }
    }

    /**
     * Í≥ÑÏ¢å Î¶¨ÏÖã (Î™®Îì† Î≥¥Ïú† Ï£ºÏãù Î∞è Í±∞ÎûòÎÇ¥Ïó≠ ÏÇ≠Ï†ú, Ï¥àÍ∏∞ ÏûêÍ∏àÏúºÎ°ú Î¶¨ÏÖã)
     */
    fun resetAccount() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            
            mockTradeRepository.resetAccount().collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.update { it.copy(isLoading = true) }
                    }
                    is Resource.Success -> {
                        // Î¶¨ÏÖã ÏôÑÎ£å ÌõÑ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Îã§Ïãú Î°úÎìú
                        loadPortfolio()
                    }
                    is Resource.Error -> {
                        _uiState.update { 
                            it.copy(
                                isLoading = false,
                                errorMessage = resource.message
                            )
                        }
                    }
                }
            }
        }
    }

    /**
     * Í≥ÑÏ¢å Ï¥àÍ∏∞Ìôî (Ïã†Í∑ú Í∞ÄÏûÖÏãú)
     */
    fun initializeAccount(initialBalance: Long = 10000000L) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            
            mockTradeRepository.initializeAccount(initialBalance).collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.update { it.copy(isLoading = true) }
                    }
                    is Resource.Success -> {
                        // Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ÌõÑ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Îã§Ïãú Î°úÎìú
                        loadPortfolio()
                    }
                    is Resource.Error -> {
                        _uiState.update { 
                            it.copy(
                                isLoading = false,
                                errorMessage = resource.message
                            )
                        }
                    }
                }
            }
        }
    }

    /**
     * Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Í∞êÏãú
     */
    private fun observeRealTimeUpdates() {
        viewModelScope.launch {
            // 500msÎßàÎã§ Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ï≤¥ÌÅ¨ (UI ÏÑ±Îä• Í≥†Î†§)
            realTimeStockCache.quotes
                .sample(500L) // UI ÏóÖÎç∞Ïù¥Ìä∏ Ïì∞Î°úÌãÄÎßÅ
                .collect { quotesMap ->
                    val currentState = _uiState.value
                    if (currentState.stockHoldings.isNotEmpty()) {
                        updatePortfolioWithRealtimeData(currentState.stockHoldings, quotesMap)
                    }
                }
        }
    }

    /**
     * Î≥¥Ïú† Ï£ºÏãù Îç∞Ïù¥ÌÑ∞Î•º ÌòÑÏû¨ Í∞ÄÍ≤©ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
     */
    private fun updatePortfolioWithCurrentData(originalHoldings: List<StockHolding>) {
        val quotesMap = realTimeStockCache.quotes.value
        updatePortfolioWithRealtimeData(originalHoldings, quotesMap)
    }

    /**
     * Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞Î°ú Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏóÖÎç∞Ïù¥Ìä∏
     */
    private fun updatePortfolioWithRealtimeData(
        originalHoldings: List<StockHolding>,
        quotesMap: Map<String, com.lago.app.domain.entity.StockRealTimeData>
    ) {
        android.util.Log.v("PortfolioViewModel", "üíπ Ïã§ÏãúÍ∞Ñ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏóÖÎç∞Ïù¥Ìä∏ - Î≥¥Ïú†Ï¢ÖÎ™©: ${originalHoldings.size}Í∞ú, Ïã§ÏãúÍ∞ÑÎç∞Ïù¥ÌÑ∞: ${quotesMap.size}Í∞ú")
        
        val updatedHoldings = originalHoldings.map { holding ->
            val realTimeData = quotesMap[holding.stockCode]
            if (realTimeData != null && holding.currentPrice != realTimeData.price.toInt()) {
                val newCurrentPrice = realTimeData.price.toInt()
                val newCurrentValue = holding.quantity.toLong() * newCurrentPrice
                val newProfitLoss = newCurrentValue - holding.totalBuyAmount
                val newProfitLossRate = if (holding.totalBuyAmount > 0) {
                    (newProfitLoss.toDouble() / holding.totalBuyAmount) * 100
                } else 0.0
                
                android.util.Log.d("PortfolioViewModel", "üìä ${holding.stockCode} Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏: ${holding.currentPrice}Ïõê ‚Üí ${newCurrentPrice}Ïõê")
                
                holding.copy(
                    currentPrice = newCurrentPrice,
                    currentValue = newCurrentValue,
                    profitLoss = newProfitLoss,
                    profitLossRate = newProfitLossRate
                )
            } else {
                holding
            }
        }
        
        // Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Ï†ÑÏ≤¥ ÏÜêÏùµ Ïû¨Í≥ÑÏÇ∞
        val totalProfitLoss = updatedHoldings.sumOf { it.profitLoss }
        val totalInvestment = updatedHoldings.sumOf { it.totalBuyAmount }
        val totalProfitLossRate = if (totalInvestment > 0) {
            (totalProfitLoss.toDouble() / totalInvestment) * 100
        } else 0.0
        
        _uiState.update { 
            it.copy(
                stockHoldings = updatedHoldings,
                totalProfitLoss = totalProfitLoss,
                totalProfitLossRate = totalProfitLossRate,
                isLoading = false
            )
        }
    }

    /**
     * ÏóêÎü¨ Î©îÏãúÏßÄ ÌÅ¥Î¶¨Ïñ¥
     */
    fun clearError() {
        _uiState.update { it.copy(errorMessage = null) }
    }

    /**
     * Í∞úÎ≥Ñ Ï¢ÖÎ™©Ïùò ÌòÑÏû¨ ÏàòÏùµÎ•† Í≥ÑÏÇ∞
     */
    fun calculateProfitLossRate(holding: StockHolding): Double {
        return if (holding.totalBuyAmount > 0) {
            (holding.profitLoss.toDouble() / holding.totalBuyAmount) * 100
        } else 0.0
    }

    /**
     * Í∞úÎ≥Ñ Ï¢ÖÎ™©Ïùò ÌòÑÏû¨ ÌèâÍ∞ÄÏï° Í≥ÑÏÇ∞
     */
    fun calculateCurrentValue(holding: StockHolding): Long {
        return holding.quantity.toLong() * holding.currentPrice
    }

    /**
     * Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÇ∞ÎèÑ Í≥ÑÏÇ∞ (Í∞Å Ï¢ÖÎ™©Ïù¥ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ÏóêÏÑú Ï∞®ÏßÄÌïòÎäî ÎπÑÏ§ë)
     */
    fun calculatePortfolioWeight(holding: StockHolding): Double {
        val state = _uiState.value
        val totalValue = state.stockHoldings.sumOf { it.currentValue }
        
        return if (totalValue > 0) {
            (holding.currentValue.toDouble() / totalValue) * 100
        } else 0.0
    }
}